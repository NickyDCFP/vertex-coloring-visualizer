{"ast":null,"code":"import'./App.css';import*as d3 from'd3';import{useEffect,useRef}from'react';import{Graph}from'./Graph';//current issues: duplicates are present in the adjacency list (as in, 1: [0, 0, 1])\n//                we still want the adjacency to go both ways, since this is an\n//                undirected graph\n//duplicates are present in the edges list, which is easy (just don't add the edge twice)\n//although maybe want to make sure that the edge that\n//they're adding, when they're adding it,\n//doesn't already exist... but can do that check in the\n//adjacency list in O(deg) time\n//maybe have pitches deepen as the recursion stack grows\n// things to ask aloupis about:\n// curved edges necessary? the internal graph can be sufficiently complex, i'm sure\n// how to host?\nimport{jsx as _jsx}from\"react/jsx-runtime\";var innerHeight=window.innerHeight;var innerWidth=window.innerWidth;var centerX=innerWidth/2;var centerY=innerHeight/2;/*\nconst radius = 7;\n\n\nconst boundsCheck = (value, bound) => {\n  if(value < radius) return radius + 10;\n  if(value > bound - radius) return bound - 10;\n  return value;\n}\n*/var App=function App(){var containerRef=useRef(null);useEffect(function(){var svg=d3.select(containerRef.current).append('svg').classed('graph-display',true).attr('width',innerWidth).attr('height',innerHeight);var graph=new Graph(svg,centerX,centerY,'#45d097',true);for(var i=0;i<5;++i)graph.addNode(0,0);for(var _i=0;_i<5;++_i){graph.addEdge(Math.floor(Math.random()*4),Math.floor(Math.random()*4));}graph.simulation.alpha(0.2).restart();console.log(graph.adj);console.log(graph.nodes);console.log(graph.edges);},[]);return/*#__PURE__*/_jsx(\"div\",{\"data-testid\":\"graphElement\",ref:containerRef});};export default App;","map":{"version":3,"names":["d3","useEffect","useRef","Graph","jsx","_jsx","innerHeight","window","innerWidth","centerX","centerY","App","containerRef","svg","select","current","append","classed","attr","graph","i","addNode","addEdge","Math","floor","random","simulation","alpha","restart","console","log","adj","nodes","edges","ref"],"sources":["C:/Users/14086/Documents/literally the only good class at this school/2/Project - Vertex Coloring/planar_graph_coloring/src/App.js"],"sourcesContent":["import './App.css';\nimport * as d3 from 'd3';\nimport {useEffect, useRef} from 'react';\nimport {Graph} from './Graph';\n\n//current issues: duplicates are present in the adjacency list (as in, 1: [0, 0, 1])\n//                we still want the adjacency to go both ways, since this is an\n//                undirected graph\n//duplicates are present in the edges list, which is easy (just don't add the edge twice)\n\n//although maybe want to make sure that the edge that\n//they're adding, when they're adding it,\n//doesn't already exist... but can do that check in the\n//adjacency list in O(deg) time\n\n//maybe have pitches deepen as the recursion stack grows\n\n// things to ask aloupis about:\n  // curved edges necessary? the internal graph can be sufficiently complex, i'm sure\n  // how to host?\nconst innerHeight = window.innerHeight;\nconst innerWidth = window.innerWidth;\nconst centerX = innerWidth / 2;\nconst centerY = innerHeight / 2;\n/*\nconst radius = 7;\n\n\nconst boundsCheck = (value, bound) => {\n  if(value < radius) return radius + 10;\n  if(value > bound - radius) return bound - 10;\n  return value;\n}\n*/\n\n\nconst App = () => {\n  const containerRef = useRef(null);\n  useEffect(() => {\n    const svg = d3.select(containerRef.current)\n      .append('svg')\n      .classed('graph-display', true)\n      .attr('width', innerWidth)\n      .attr('height', innerHeight);\n    const graph = new Graph(svg, centerX, centerY, '#45d097', true);\n    for(let i = 0; i < 5; ++i) graph.addNode(0, 0);\n    for(let i = 0; i < 5; ++i) {\n      graph.addEdge(Math.floor(Math.random() * 4), Math.floor(Math.random() * 4));\n    }\n\n    graph.simulation.alpha(0.2).restart();\n    console.log(graph.adj);\n    console.log(graph.nodes);\n    console.log(graph.edges);\n  }, []);\n\n  return <div data-testid=\"graphElement\" ref={containerRef} />\n}\n\nexport default App;"],"mappings":"AAAA,MAAO,WAAW,CAClB,MAAO,GAAK,CAAAA,EAAE,KAAM,IAAI,CACxB,OAAQC,SAAS,CAAEC,MAAM,KAAO,OAAO,CACvC,OAAQC,KAAK,KAAO,SAAS,CAE7B;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACE;AACA;AAAA,OAAAC,GAAA,IAAAC,IAAA,yBACF,GAAM,CAAAC,WAAW,CAAGC,MAAM,CAACD,WAAW,CACtC,GAAM,CAAAE,UAAU,CAAGD,MAAM,CAACC,UAAU,CACpC,GAAM,CAAAC,OAAO,CAAGD,UAAU,CAAG,CAAC,CAC9B,GAAM,CAAAE,OAAO,CAAGJ,WAAW,CAAG,CAAC,CAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAGA,GAAM,CAAAK,GAAG,CAAG,QAAN,CAAAA,GAAGA,CAAA,CAAS,CAChB,GAAM,CAAAC,YAAY,CAAGV,MAAM,CAAC,IAAI,CAAC,CACjCD,SAAS,CAAC,UAAM,CACd,GAAM,CAAAY,GAAG,CAAGb,EAAE,CAACc,MAAM,CAACF,YAAY,CAACG,OAAO,CAAC,CACxCC,MAAM,CAAC,KAAK,CAAC,CACbC,OAAO,CAAC,eAAe,CAAE,IAAI,CAAC,CAC9BC,IAAI,CAAC,OAAO,CAAEV,UAAU,CAAC,CACzBU,IAAI,CAAC,QAAQ,CAAEZ,WAAW,CAAC,CAC9B,GAAM,CAAAa,KAAK,CAAG,GAAI,CAAAhB,KAAK,CAACU,GAAG,CAAEJ,OAAO,CAAEC,OAAO,CAAE,SAAS,CAAE,IAAI,CAAC,CAC/D,IAAI,GAAI,CAAAU,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG,CAAC,CAAE,EAAEA,CAAC,CAAED,KAAK,CAACE,OAAO,CAAC,CAAC,CAAE,CAAC,CAAC,CAC9C,IAAI,GAAI,CAAAD,EAAC,CAAG,CAAC,CAAEA,EAAC,CAAG,CAAC,CAAE,EAAEA,EAAC,CAAE,CACzBD,KAAK,CAACG,OAAO,CAACC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,CAAG,CAAC,CAAC,CAAEF,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,CAAG,CAAC,CAAC,CAAC,CAC7E,CAEAN,KAAK,CAACO,UAAU,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,EAAE,CACrCC,OAAO,CAACC,GAAG,CAACX,KAAK,CAACY,GAAG,CAAC,CACtBF,OAAO,CAACC,GAAG,CAACX,KAAK,CAACa,KAAK,CAAC,CACxBH,OAAO,CAACC,GAAG,CAACX,KAAK,CAACc,KAAK,CAAC,CAC1B,CAAC,CAAE,EAAE,CAAC,CAEN,mBAAO5B,IAAA,QAAK,cAAY,cAAc,CAAC6B,GAAG,CAAEtB,YAAa,EAAG,CAC9D,CAAC,CAED,cAAe,CAAAD,GAAG"},"metadata":{},"sourceType":"module","externalDependencies":[]}
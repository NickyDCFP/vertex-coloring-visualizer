{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\14086\\\\Documents\\\\literally the only good class at this school\\\\2\\\\Project - Vertex Coloring\\\\planar_graph_coloring\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport logo from './logo.svg';\nimport './App.css';\nimport * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport { Graph } from './Graph';\n\n//current issues: duplicates are present in the adjacency list (as in, 1: [0, 0, 1])\n//                we still want the adjacency to go both ways, since this is an\n//                undirected graph\n//duplicates are present in the edges list, which is easy (just don't add the edge twice)\n\n//although maybe want to make sure that the edge that\n//they're adding, when they're adding it,\n//doesn't already exist... but can do that check in the\n//adjacency list in O(deg) time\n\n//maybe have pitches deepen as the recursion stack grows\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst innerHeight = window.innerHeight;\nconst innerWidth = window.innerWidth;\nconst centerX = innerWidth / 2;\nconst centerY = innerHeight / 2;\nconst radius = 7;\nconst showLabels = false;\nconst boundsCheck = (value, bound) => {\n  if (value < radius) return radius + 10;\n  if (value > bound - radius) return bound - 10;\n  return value;\n};\nconst handleClick = (event, node) => {\n  event.stopPropagation();\n  console.log(event.target.tagName);\n  console.log(node);\n};\nconst App = () => {\n  _s();\n  const containerRef = useRef(null);\n  useEffect(() => {\n    const svg = d3.select(containerRef.current).append('svg').attr('width', innerWidth).attr('height', innerHeight);\n    const graph = new Graph(svg, centerX, centerY, '#45d097');\n    for (let i = 0; i < 30; ++i) graph.addNode();\n    for (let i = 0; i < 30; ++i) {\n      graph.addEdge(Math.floor(Math.random() * 29), Math.floor(Math.random() * 29));\n    }\n\n    // const text = svg\n    //   .selectAll('text')\n    //   .data(graph.nodes)\n    //   .enter()\n    //   .append('text')\n    //   .attr('text-anchor', 'middle')\n    //   .attr('alignment-baseline', 'middle')\n    //   .style('pointer-events', 'none')\n    //   .style('user-select', 'none')\n    //   .text(node => showLabels ? node.id : \"\");\n\n    // graph.simulation.on(\"tick\", () => {\n    //   // circles\n    //   //   .attr('cx', node => boundsCheck(node.x, innerWidth))\n    //   //   .attr('cy', node => boundsCheck(node.y, innerHeight));\n    //   text\n    //     .attr('x', node => node.x)\n    //     .attr('y', node => node.y);\n    //   lines\n    //     .attr('x1', edge => boundsCheck(edge.source.x, innerWidth))\n    //     .attr('x2', edge => boundsCheck(edge.target.x, innerWidth))\n    //     .attr('y1', edge => boundsCheck(edge.source.y, innerHeight))\n    //     .attr('y2', edge => boundsCheck(edge.target.y, innerHeight));\n    // });\n    graph.simulation.alpha(0.2).restart();\n    console.log(graph.adj);\n    console.log(graph.nodes);\n    console.log(graph.edges);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 80,\n    columnNumber: 10\n  }, this);\n};\n_s(App, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["logo","d3","useEffect","useRef","Graph","jsxDEV","_jsxDEV","innerHeight","window","innerWidth","centerX","centerY","radius","showLabels","boundsCheck","value","bound","handleClick","event","node","stopPropagation","console","log","target","tagName","App","_s","containerRef","svg","select","current","append","attr","graph","i","addNode","addEdge","Math","floor","random","simulation","alpha","restart","adj","nodes","edges","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/14086/Documents/literally the only good class at this school/2/Project - Vertex Coloring/planar_graph_coloring/src/App.js"],"sourcesContent":["import logo from './logo.svg';\nimport './App.css';\nimport * as d3 from 'd3';\nimport {useEffect, useRef} from 'react';\nimport {Graph} from './Graph'\n\n//current issues: duplicates are present in the adjacency list (as in, 1: [0, 0, 1])\n//                we still want the adjacency to go both ways, since this is an\n//                undirected graph\n//duplicates are present in the edges list, which is easy (just don't add the edge twice)\n\n//although maybe want to make sure that the edge that\n//they're adding, when they're adding it,\n//doesn't already exist... but can do that check in the\n//adjacency list in O(deg) time\n\n//maybe have pitches deepen as the recursion stack grows\nconst innerHeight = window.innerHeight;\nconst innerWidth = window.innerWidth;\nconst centerX = innerWidth / 2;\nconst centerY = innerHeight / 2;\nconst radius = 7;\nconst showLabels = false;\n\nconst boundsCheck = (value, bound) => {\n  if(value < radius) return radius + 10;\n  if(value > bound - radius) return bound - 10;\n  return value;\n}\n\nconst handleClick = (event, node) => {\n  event.stopPropagation();\n  console.log(event.target.tagName);\n  console.log(node);\n}\n\nconst App = () => {\n  const containerRef = useRef(null);\n  useEffect(() => {\n    const svg = d3.select(containerRef.current)\n      .append('svg')\n      .attr('width', innerWidth)\n      .attr('height', innerHeight);\n    const graph = new Graph(svg, centerX, centerY, '#45d097');\n    for(let i = 0; i < 30; ++i) graph.addNode();\n    for(let i = 0; i < 30; ++i) {\n      graph.addEdge(Math.floor(Math.random() * 29), Math.floor(Math.random() * 29));\n    }\n\n    // const text = svg\n    //   .selectAll('text')\n    //   .data(graph.nodes)\n    //   .enter()\n    //   .append('text')\n    //   .attr('text-anchor', 'middle')\n    //   .attr('alignment-baseline', 'middle')\n    //   .style('pointer-events', 'none')\n    //   .style('user-select', 'none')\n    //   .text(node => showLabels ? node.id : \"\");\n\n    // graph.simulation.on(\"tick\", () => {\n    //   // circles\n    //   //   .attr('cx', node => boundsCheck(node.x, innerWidth))\n    //   //   .attr('cy', node => boundsCheck(node.y, innerHeight));\n    //   text\n    //     .attr('x', node => node.x)\n    //     .attr('y', node => node.y);\n    //   lines\n    //     .attr('x1', edge => boundsCheck(edge.source.x, innerWidth))\n    //     .attr('x2', edge => boundsCheck(edge.target.x, innerWidth))\n    //     .attr('y1', edge => boundsCheck(edge.source.y, innerHeight))\n    //     .attr('y2', edge => boundsCheck(edge.target.y, innerHeight));\n    // });\n    graph.simulation.alpha(0.2).restart();\n    console.log(graph.adj);\n    console.log(graph.nodes);\n    console.log(graph.edges);\n  }, []);\n\n  return <div ref={containerRef} />\n}\n\nexport default App;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
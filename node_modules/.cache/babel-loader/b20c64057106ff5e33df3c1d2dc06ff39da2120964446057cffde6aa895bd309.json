{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\14086\\\\Documents\\\\literally the only good class at this school\\\\2\\\\Project - Vertex Coloring\\\\planar_graph_coloring\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport './App.css';\nimport * as d3 from 'd3';\nimport { useEffect, useRef } from 'react';\nimport { Graph } from './Graph';\n\n//current issues: duplicates are present in the adjacency list (as in, 1: [0, 0, 1])\n//                we still want the adjacency to go both ways, since this is an\n//                undirected graph\n//duplicates are present in the edges list, which is easy (just don't add the edge twice)\n\n//although maybe want to make sure that the edge that\n//they're adding, when they're adding it,\n//doesn't already exist... but can do that check in the\n//adjacency list in O(deg) time\n\n//maybe have pitches deepen as the recursion stack grows\n\n// things to ask aloupis about:\n// curved edges necessary? the internal graph can be sufficiently complex, i'm sure\n// how to host?\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst innerHeight = window.innerHeight;\nconst innerWidth = window.innerWidth;\nconst centerX = innerWidth / 2;\nconst centerY = innerHeight / 2;\nconst radius = 7;\n\n// const boundsCheck = (value, bound) => {\n//   if(value < radius) return radius + 10;\n//   if(value > bound - radius) return bound - 10;\n//   return value;\n// }\n\nconst App = () => {\n  _s();\n  const containerRef = useRef(null);\n  useEffect(() => {\n    const svg = d3.select(containerRef.current).append('svg').attr('width', innerWidth).attr('height', innerHeight);\n    const graph = new Graph(svg, centerX, centerY, '#45d097', true);\n    for (let i = 0; i < 5; ++i) graph.addNode(0, 0);\n    for (let i = 0; i < 5; ++i) {\n      graph.addEdge(Math.floor(Math.random() * 4), Math.floor(Math.random() * 4));\n    }\n    graph.simulation.alpha(0.2).restart();\n    console.log(graph.adj);\n    console.log(graph.nodes);\n    console.log(graph.edges);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 54,\n    columnNumber: 10\n  }, this);\n};\n_s(App, \"8puyVO4ts1RhCfXUmci3vLI3Njw=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["d3","useEffect","useRef","Graph","jsxDEV","_jsxDEV","innerHeight","window","innerWidth","centerX","centerY","radius","App","_s","containerRef","svg","select","current","append","attr","graph","i","addNode","addEdge","Math","floor","random","simulation","alpha","restart","console","log","adj","nodes","edges","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/14086/Documents/literally the only good class at this school/2/Project - Vertex Coloring/planar_graph_coloring/src/App.js"],"sourcesContent":["import './App.css';\nimport * as d3 from 'd3';\nimport {useEffect, useRef} from 'react';\nimport {Graph} from './Graph'\n\n//current issues: duplicates are present in the adjacency list (as in, 1: [0, 0, 1])\n//                we still want the adjacency to go both ways, since this is an\n//                undirected graph\n//duplicates are present in the edges list, which is easy (just don't add the edge twice)\n\n//although maybe want to make sure that the edge that\n//they're adding, when they're adding it,\n//doesn't already exist... but can do that check in the\n//adjacency list in O(deg) time\n\n//maybe have pitches deepen as the recursion stack grows\n\n// things to ask aloupis about:\n  // curved edges necessary? the internal graph can be sufficiently complex, i'm sure\n  // how to host?\nconst innerHeight = window.innerHeight;\nconst innerWidth = window.innerWidth;\nconst centerX = innerWidth / 2;\nconst centerY = innerHeight / 2;\nconst radius = 7;\n\n// const boundsCheck = (value, bound) => {\n//   if(value < radius) return radius + 10;\n//   if(value > bound - radius) return bound - 10;\n//   return value;\n// }\n\n\n\nconst App = () => {\n  const containerRef = useRef(null);\n  useEffect(() => {\n    const svg = d3.select(containerRef.current)\n      .append('svg')\n      .attr('width', innerWidth)\n      .attr('height', innerHeight);\n    const graph = new Graph(svg, centerX, centerY, '#45d097', true);\n    for(let i = 0; i < 5; ++i) graph.addNode(0, 0);\n    for(let i = 0; i < 5; ++i) {\n      graph.addEdge(Math.floor(Math.random() * 4), Math.floor(Math.random() * 4));\n    }\n\n    graph.simulation.alpha(0.2).restart();\n    console.log(graph.adj);\n    console.log(graph.nodes);\n    console.log(graph.edges);\n  }, []);\n\n  return <div ref={containerRef} />\n}\n\nexport default App;"],"mappings":";;AAAA,OAAO,WAAW;AAClB,OAAO,KAAKA,EAAE,MAAM,IAAI;AACxB,SAAQC,SAAS,EAAEC,MAAM,QAAO,OAAO;AACvC,SAAQC,KAAK,QAAO,SAAS;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACE;AACA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACF,MAAMC,WAAW,GAAGC,MAAM,CAACD,WAAW;AACtC,MAAME,UAAU,GAAGD,MAAM,CAACC,UAAU;AACpC,MAAMC,OAAO,GAAGD,UAAU,GAAG,CAAC;AAC9B,MAAME,OAAO,GAAGJ,WAAW,GAAG,CAAC;AAC/B,MAAMK,MAAM,GAAG,CAAC;;AAEhB;AACA;AACA;AACA;AACA;;AAIA,MAAMC,GAAG,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAChB,MAAMC,YAAY,GAAGZ,MAAM,CAAC,IAAI,CAAC;EACjCD,SAAS,CAAC,MAAM;IACd,MAAMc,GAAG,GAAGf,EAAE,CAACgB,MAAM,CAACF,YAAY,CAACG,OAAO,CAAC,CACxCC,MAAM,CAAC,KAAK,CAAC,CACbC,IAAI,CAAC,OAAO,EAAEX,UAAU,CAAC,CACzBW,IAAI,CAAC,QAAQ,EAAEb,WAAW,CAAC;IAC9B,MAAMc,KAAK,GAAG,IAAIjB,KAAK,CAACY,GAAG,EAAEN,OAAO,EAAEC,OAAO,EAAE,SAAS,EAAE,IAAI,CAAC;IAC/D,KAAI,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAED,KAAK,CAACE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAC9C,KAAI,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;MACzBD,KAAK,CAACG,OAAO,CAACC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAG,CAAC,CAAC,EAAEF,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC;IAC7E;IAEAN,KAAK,CAACO,UAAU,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,EAAE;IACrCC,OAAO,CAACC,GAAG,CAACX,KAAK,CAACY,GAAG,CAAC;IACtBF,OAAO,CAACC,GAAG,CAACX,KAAK,CAACa,KAAK,CAAC;IACxBH,OAAO,CAACC,GAAG,CAACX,KAAK,CAACc,KAAK,CAAC;EAC1B,CAAC,EAAE,EAAE,CAAC;EAEN,oBAAO7B,OAAA;IAAK8B,GAAG,EAAErB;EAAa;IAAAsB,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,QAAG;AACnC,CAAC;AAAA1B,EAAA,CApBKD,GAAG;AAAA4B,EAAA,GAAH5B,GAAG;AAsBT,eAAeA,GAAG;AAAC,IAAA4B,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}